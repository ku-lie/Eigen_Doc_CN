## 入门

这是一个关于如何开始使用[Eigen](Eigen命名空间.html)的简短指南。 它有双重目的。对于希望尽快开始编码的人来说，它只是对[Eigen](Eigen命名空间.html)库的一个简单介绍。您也可以将本页作为教程的第一部分阅读，其中对库进行了更详细的解释；在这种情况下，您将继续使用[Matrix类](矩阵类教程.md)。

### 如何“安装”Eigen？

为了使用[Eigen](Eigen命名空间.html)，您只需要下载并提取[Eigen](Eigen命名空间.html)的源代码（有关下载说明，请参阅[wiki](http://eigen.tuxfamily.org/index.php?title=Main_Page#Download)）。事实上，Eigen子目录中的头文件是使用Eigen编译程序所需的唯一文件。 所有平台的头文件都相同。没有必要使用CMake或安装任何东西。

### 一个简单的第一个程序

这里有一个相当简单的程序让你开始。

```cpp
#include <iostream>
#include <Eigen/Dense>

using Eigen::MatrixXd;

int main()
{
  MatrixXd m(2,2);
  m(0,0) = 3;
  m(1,0) = 2.5;
  m(0,1) = -1;
  m(1,1) = m(1,0) + m(0,1);
  std::cout << m << std::endl;
}
```
在告诉您如何编译程序后，我们将解释该程序。


### 编译并运行第一个程序

没有可链接的库。编译上述程序时，您需要记住的唯一一件事是编译器必须能够找到Eigen头文件。您放置Eigen源代码的目录必须在包含路径中。在GCC中，你可以使用-I选项来实现这一点，因此你可以用这样的命令来编译程序：

```powershell
g++ -I /path/to/eigen/ my_program.cpp -o my_program
```

在Linux或Mac OS X上，另一个选项是将Eigen文件夹符号链接或复制到/usr/local/include/中。这样，您可以使用以下工具编译程序：

```shell
g++ my_program.cpp -o my_program
```

运行程序时，它会产生以下输出：
```powershell
  3  -1
2.5 1.5
```
### 第一个程序的说明

[Eigen](Eigen命名空间.html)头文件定义了许多类型，但对于简单的应用程序，仅使用MatrixXd类型就足够了。这表示任意大小的矩阵 (MatrixXd中的X），其中每个条目都是双精度的 (MatrixXd中的d）。有关可用于表示矩阵的不同类型的概述，请参阅[《快速参考指南》](group__QuickRefPage.html#QuickRef_Types)。

Eigen/Dense头文件定义了MatrixXd类型和相关类型的所有成员函数（另请参见[头文件表](group__QuickRefPage.html#QuickRef_Headers)）。 此头文件（以及其他[Eigen](Eigen命名空间.html)头文件）中定义的所有类和函数都位于Eigen命名空间中。

main函数的第一行声明了一个MatrixXd类型的变量，并指定它是一个具有2行2列的矩阵（条目未初始化）。声明 m(0, 0) = 3 将左上角的条目设置为3。 您需要使用圆括号来引用矩阵中的条目。与计算机科学中的通常情况一样，第一个索引的索引为0，而数学中的惯例是第一个索引为1。

以下三条语句设置了其他三个条目。最后一行将矩阵m输出到标准输出流。

### 示例2：矩阵和向量

这里是另一个例子，它将矩阵与向量相结合。现在专注于第一个程序；稍后我们将讨论第二个程序。

运行时设置的大小：

```cpp
#include <iostream>
#include <Eigen/Dense>

using Eigen::MatrixXd;
using Eigen::VectorXd;

int main()
{
    MatrixXd m = MatrixXd::Random(3,3);
    m = (m + MatrixXd::Constant(3,3,1.2)) * 50;
    std::cout << "m =" << std::endl << m << std::endl;
    VectorXd v(3);
    v << 1, 2, 3;
    std::cout << "m * v =" << std::endl << m * v << std::endl;
}
```

编译时设置的大小：

```cpp
#include <iostream>
#include <Eigen/Dense>

using Eigen::Matrix3d;
using Eigen::Vector3d;

int main()
{
    Matrix3d m = Matrix3d::Random();
    m = (m + Matrix3d::Constant(1.2)) * 50;
    std::cout << "m =" << std::endl << m << std::endl;
    Vector3d v(1,2,3);
    std::cout << "m * v =" << std::endl << m * v << std::endl;
}
```
输出如下：
```powershell
m =
  94 89.8 43.5
49.4  101 86.8
88.3 29.8 37.8
m * v =
404
512
261
```
### 第二个示例的解释
第二个示例首先声明一个3乘3的矩阵m，该矩阵使用[Random()](classEigen_1_1DenseBase.html#ae97f8d9d08f969c733c8144be6225756)方法初始化，随机值介于-1和1之间。 下一行应用线性映射，使值介于10和110之间。 函数调用[MatrixXd::Constant(3,3,1.2)](classEigen_1_1DenseBase.html#a68a7ece6c5629d1e9447a321fcb14ccd)返回一个3乘3的矩阵表达式，其所有元素均等于1.2。其余的是标准算术。

主函数的下一行引入了一种新类型：VectorXd。这表示任意大小的（列）向量。这里，向量v被创建为包含3个未初始化的元素。 最后一行使用所谓的逗号初始化器（在[高级初始化](group__TutorialAdvancedInitialization.html)中解释），将向量v的所有元素设置为如下所示：
$$v=\begin{bmatrix}1\\2\\3\end{bmatrix}$$
程序的最后一行将矩阵m与向量v相乘，并输出结果。

现在回头看第二个示例程序。 我们介绍了它的两个版本。在第一个程序的版本中，矩阵为MatrixXd类型，表示任意大小的矩阵。第二个程序中的版本类似，只是矩阵是Matrix3d类型，它表示固定大小的矩阵（此处为3×3）。 因为类型已经编码了矩阵的大小，所以不需要在构造函数中指定大小；比较MatrixXd m(3,3)和Matrix3d m。类似地，我们在左边有VectorXd（任意大小）而在右边有Vector3d（固定大小）。 注意，这里向量v的元素直接在构造函数中设置，尽管也可以使用第一个程序的相同语法。

使用固定大小的矩阵和向量有两个优点。 编译器发出更好（更快）的代码，因为它知道矩阵和向量的大小。在类型中指定大小还允许在编译时进行更严格的检查。例如，如果您试图将矩阵4d（4×4矩阵）与向量3d（大小为3的向量）相乘，编译器会报错。然而，许多类型的使用增加了编译时间和可执行文件的大小。矩阵的大小在编译时也可能未知。经验法则是对4×4及更小的尺寸使用固定尺寸矩阵。
### 从这里到哪里去？
花点时间阅读这篇[冗长的教程](矩阵类教程.md)是值得的。

但是，如果您认为不需要它，可以直接使用类文档和我们的[快速参考指南](group__QuickRefPage.html)。

接下来：[矩阵类](矩阵类教程.md)