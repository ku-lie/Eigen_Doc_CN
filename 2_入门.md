## 入门

这是一个关于如何开始使用[Eigen](6_类列表/1_Eigen/readme.md))的简短指南。 它有双重目的。对于希望尽快开始编码的人来说，它只是对Eigen库的一个简单介绍。您也可以将本页作为教程的第一部分阅读，其中对库进行了更详细的解释；在这种情况下，您将继续使用[Matrix类](3_章节/1_密集矩阵和数组操作/1_Matrix类.md))。

### 如何“安装”Eigen？

为了使用Eigen，您只需要下载并提取Eigen的源代码（有关下载说明，请参阅[wiki](http://eigen.tuxfamily.org/index.php?title=Main_Page#Download)）。事实上，Eigen子目录中的头文件是使用Eigen编译程序所需的唯一文件。 所有平台的头文件都相同。没有必要使用CMake或安装任何东西。

### 一个简单的第一个程序

这里有一个相当简单的程序让你开始。

```cpp
#include <iostream>
#include <Eigen/Dense>

using Eigen::MatrixXd;

int main()
{
  MatrixXd m(2,2);
  m(0,0) = 3;
  m(1,0) = 2.5;
  m(0,1) = -1;
  m(1,1) = m(1,0) + m(0,1);
  std::cout << m << std::endl;
}
```

在告诉您如何编译程序后，我们将解释该程序。

### 编译并运行第一个程序

没有可链接的库。编译上述程序时，您需要记住的唯一一件事是编译器必须能够找到Eigen头文件。您放置Eigen源代码的目录必须在包含路径中。在GCC中，你可以使用 *-I* 选项来实现这一点，因此你可以用这样的命令来编译程序：

```powershell
g++ -I /path/to/eigen/ my_program.cpp -o my_program
```

在Linux或Mac OS X上，另一个选项是将Eigen文件夹符号链接或复制到 */usr/local/include/* 中。这样，您可以使用以下工具编译程序：

```shell
g++ my_program.cpp -o my_program
```

运行程序时，它会产生以下输出：

```powershell
  3  -1
2.5 1.5
```

### 第一个程序的说明

Eigen头文件定义了许多类型，但对于简单的应用程序，仅使用*MatrixXd*类型就足够了。这表示任意大小的矩阵 (*MatrixXd*中的*X*），其中每个条目都是双精度的 (*MatrixXd*中的*d*）。有关可用于表示矩阵的不同类型的概述，请参阅[《快速参考指南》](3_章节/1_密集矩阵和数组操作/16_快速参考指南.md#数组矩阵和向量类型)。

*Eigen/Dense*头文件定义了MatrixXd类型和相关类型的所有成员函数（另请参见[头文件表](3_章节/1_密集矩阵和数组操作/16_快速参考指南.md#模块和头文件)）。 此头文件（以及其他Eigen头文件）中定义的所有类和函数都位于Eigen命名空间中。
*main*函数的第一行声明了一个*MatrixXd*类型的变量，并指定它是一个具有2行2列的矩阵（未初始化）。声明*m(0, 0) = 3* 将左上角的条目设置为3。 您需要使用圆括号来引用矩阵中的条目。与计算机科学中的通常情况一样，第一个索引的索引为0，而数学中的惯例是第一个索引为1。

以下三条语句设置了其他三个条目。最后一行将矩阵*m*输出到标准输出流。

### 示例2：矩阵和向量

这里是另一个例子，它将矩阵与向量相结合。现在专注于第一个程序；稍后我们将讨论第二个程序。

运行时设置的大小：

```cpp
#include <iostream>
#include <Eigen/Dense>

using Eigen::MatrixXd;
using Eigen::VectorXd;

int main()
{
    MatrixXd m = MatrixXd::Random(3,3);
    m = (m + MatrixXd::Constant(3,3,1.2)) * 50;
    std::cout << "m =" << std::endl << m << std::endl;
    VectorXd v(3);
    v << 1, 2, 3;
    std::cout << "m * v =" << std::endl << m * v << std::endl;
}
```

编译时设置的大小：

```cpp
#include <iostream>
#include <Eigen/Dense>

using Eigen::Matrix3d;
using Eigen::Vector3d;

int main()
{
    Matrix3d m = Matrix3d::Random();
    m = (m + Matrix3d::Constant(1.2)) * 50;
    std::cout << "m =" << std::endl << m << std::endl;
    Vector3d v(1,2,3);
    std::cout << "m * v =" << std::endl << m * v << std::endl;
}
```

输出如下：

```powershell
m =
  94 89.8 43.5
49.4  101 86.8
88.3 29.8 37.8
m * v =
404
512
261
```

### 第二个示例的解释

第二个示例首先声明一个3乘3的矩阵m，该矩阵使用[Random()](6_类列表/1_Eigen/34_DenseBase.md#random-23)方法初始化，随机值介于-1和1之间。 下一行应用线性映射，使值介于10和110之间。 函数调用[MatrixXd:: Constant](6_类列表/1_Eigen/34_DenseBase.md#constant-23)(3, 3, 1.2)返回一个3乘3的矩阵表达式，其所有元素均等于1.2。其余的是标准算术。

主函数的下一行引入了一种新类型：*VectorXd*。这表示任意大小的（列）向量。这里，向量v被创建为包含3个未初始化的元素。 最后一行使用所谓的逗号初始化器（在[高级初始化](3_章节/1_密集矩阵和数组操作/6_高级初始化.md)中解释），将向量*v*的所有元素设置为如下所示：

![](http://latex.codecogs.com/svg.latex?v=\begin{bmatrix}1\\\2\\\3\end{bmatrix})

程序的最后一行将矩阵*m*与向量*v*相乘，并输出结果。

现在回头看第二个示例程序。我们介绍了它的两个版本。在第一个程序的版本中，矩阵为*MatrixXd*类型，表示任意大小的矩阵。第二个程序中的版本类似，只是矩阵是*Matrix3d*类型，它表示固定大小的矩阵（此处为3×3）。 因为类型已经编码了矩阵的大小，所以不需要在构造函数中指定大小；比较*MatrixXd m(3, 3)*和*Matrix3d m*。类似地，我们在左边有*VectorXd*（任意大小）而在右边有*Vector3d*（固定大小）。 注意，这里向量v的元素直接在构造函数中设置，尽管也可以使用第一个程序的相同语法。

使用固定大小的矩阵和向量有两个优点。 编译器发出更好（更快）的代码，因为它知道矩阵和向量的大小。在类型中指定大小还允许在编译时进行更严格的检查。例如，如果您试图将*Matrix4d*（4×4矩阵）与*Vector3d*（大小为3的向量）相乘，编译器会报错。然而，许多类型的使用增加了编译时间和可执行文件的大小。矩阵的大小在编译时也可能未知。经验法则是对4×4及更小的尺寸使用固定尺寸矩阵。

### 从这里到哪里去？

花点时间阅读这篇[长长的教程](3_章节/1_密集矩阵和数组操作/1_Matrix类.md)是值得的。

但是，如果您认为不需要它，可以直接使用类文档和我们的[快速参考指南](3_章节/1_密集矩阵和数组操作/16_快速参考指南.md)。

* 接下来：[矩阵类](3_章节/1_密集矩阵和数组操作/1_Matrix类.md)
